This Axios program serves to prove Axios's Turing completeness by recreating a Turing complete cellular automaton, namely, a
left-to-right variation of Rule One Hundred Ten (also known as Rule One Hundred Twenty-Four).

To run this program:
  *  Download the appropriate Axios implementation.
  *  Download this file, or copy and paste its contents into a file on your computer.
  *  Run the Axios interpreter via a command-line application. (eg. Command Prompt for Windows or Terminal for Mac)
  *  Type zero and press enter.
  *  Type the file's name and press enter.
  *  Type the first line of the Rule One Hundred Ten sequence and press enter, with ones representing full cells and zeroes
     representing empty cells. Typing nothing and pressing enter will initialize Rule One Hundred Ten with only one full cell.


The information in the "Guide to Axios" pdf file is essential to understanding this proof, so check it out if you are
interested. In addition, I should clarify several things before explaining the program:

  *  The program itself is split into three sections, labeled for the order in which they occur in the program. Due to how
     states reference other states in Axios, Section I appears at the top, Section II at the bottom, and Section III in the
     center. This organizational style serves to reduce the number of operations.
     
  *  Because of how long a single line of code can be, any cluster of code that does not contain two newline characters in a row
     should be read as one line of code (C states being the exception). Unless otherwise noted, the program typically reads
     states in a line of code from left to right.
     *  There are a lot of states in this program that contain four hundred twenty-two zeroes. This simply makes the referenced
        state the same as the next state written in code, so the next state will be the same regardless of the value of the bit
        under the pointer. If you see a state with a large number of zeroes without a comment as to what it references, assume
        it will go to the state immediately to the right.
     *  A state containing a zero operator followed by a one operator changes the bit under the pointer once or twice until it
        becomes zero. Similarly, it must eventually lead to the state immediately to the right.

  *  This program contains four hundred twenty-one states (in addition to the termination state). Some states receive letter or
     multi-letter names, which will appear immediately before two arrows ( >> ) pointing to the first zero, two, or three
     operator of the state (or if none exist, the one operator immediately following said state). One operators divide states,
     and each belongs to no particular state.
     *  A state that references a named state will contain similar notation, with the arrow ( -> ) pointing TOWARDS the
        referenced state.
     *  For some states that reference a named state, it is possible for the bit under the pointer to be read as zero, thus
        negating the referenced state and instead moving to the next state noted in code. In these cases, a curly arrow ( ~> )
        is used.
     *  There is at least one state that is not actually accessible, and it is surrounded by a pair of the symbol !>. Note that
        State KA can be called by other states, but not this unreachable state. (For the sake of the proof of Turing completeness,
        it is easier to leave this state in the code than prove it can't be reached.)

  *  Everything that does not contain numerals is a comment. This may lead to spelling out numbers awkwardly (namely, spelling
     out Rule One Hundred Ten), but this is necessary to ensure the interpreter does not read comments as code.

  *  Rule One Hundred Ten and Axios both have cells as the fundamental unit. To avoid confusion, this program refers to Rule One
     Hundred Ten cells simply as "cells", and Axios cells as "bits". (Technically, an implementation does not have to store
     Axios cells as bits, but the implementation available in this repository does.)

  *  In Axios's list of bits, every four bits will represent one cell.
     *  The first bit being one indicates there is a valid cell. If the first bit is zero, no valid cell follows, and all
        following bits must also be zero.
     *  The second bit marks a cell as being the current focus of the program.
     *  The third bit displays the cell's current value.
     *  The fourth bit displays the cell's previous value.
     *  Here's an example of four cells as represented in Axios:
        *  Cell values: one zero one one
        *  Bit values: (one one one one) (one zero zero zero) (one zero one one) (one zero one one) zero zero zero...



Section I:

This section is the simplest. From left to right, it moves the pointer thirty three times to create the first eight bits, which
will soon become the sequence: (one one one one) (one zero zero zero)...

The last state in this section has forty zeroes, which indicates a shift to State B at the bottom of this program.

State A (start of program) >> 1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1
1    1    1    1    1    1    1    1    1    1    01    1    1    01    1
00000000000000000000000000000000000000001 -> State B



Section III

T states

Once the T states are reached, there is enough information to know the current cell should be empty (third bit should be zero),
and the program updates accordingly.

This line changes the value of the third bit to zero and moves the pointer over the fourth bit without changing it (technically
changing it twice, which has the same effect). At this point, the bit under the pointer belongs to the next cell. The bit will be
zero (indicating the absence of a valid cell), so the program goes to State U. (I left the option to go State KA despite the
fact that the bit must be zero. Proving it would just make this code denser than it already is.)
State TE >> 1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000001 -> State U    0000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
!> 0000000000000000000000000000000000000000000000000000000001 !> State KA

This line of code travels across the cells, looking for the cell whose second bit is one (the current cell). When that cell is
found, the program moves the pointer to the third bit and redirects to State TE.
State TD >> 1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001    1    State TC >> 01
1    000000001 ~> State TD    1    01    00000000000000001 -> State TE

This line navigates to the first valid cell and redirects to State TC.
State TB >> 1    001 ~> State TB    0000000001 -> State TC

This line travels four bits at a time (one cell at a time) until the first bit after all the valid cells has been reached, then
it redirects to State TB.
State TA >> 01    1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001    1
State T >> 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000001   1    0000000000001 ~> State TB    00000000001 -> State TA


S states

Once the S states are reached, there is enough information to know the current cell should be full (third bit should be one),
and the program updates accordingly.

This line of code travels across the cells, looking for the cell whose second bit is one (the current cell). When that cell is
found, the program moves the pointer, changes the third bit to one, and moves the pointer over the fourth bit without changing
it (technically changing it twice, which has the same effect). At this point, the bit under the pointer belongs to the next
cell. If the bit was zero (indicating the absence of a valid cell) the program goes to State U. Otherwise, it goes to State KA.
State SD >> 1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001    1    State SC >> 01
1    000000001 ~> State SD    1    01    1    0000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000001    1    0000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00001 ~> State U    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000001 -> State KA

At this point, the pointer lies on the first bit past all the valid cells. This line navigates to the first valid cell and
redirects to State SC.
State SB >> 1    001 ~> State SB    00000000000001 -> State SC

This line travels four bits at a time (one cell at a time) until the first bit after all the valid cells has been reached, then
it redirects to State SB.
State SA >> 01    1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001    1    000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000001    State S >> 1    0000000000001 ~> State SB    00000000001 -> State SA


This line of code is called if the previous cell's and current cell's third bits were both one. It now branches out based on the
fourth bit of the following cell. If there is no valid cell that follows (first bit after the current cell was zero, indicated
by it immediately changing to one), the program immediately redirects to State SB. Otherwise, if the fourth bit of the following
was zero (immediately changes to one), the program goes to State S. If the fourth bit was one (changes to zero and then changes
to one), the program goes to State T.

State R >> 01    1    00000000000000001 ~> State SB    1    00000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001    1    00000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000001    1    0000000000001 ~> State S    0000000000000000000000000000000000000000001 -> State T


Q states

Once the Q states are reached, there is enough information to know the current cell should be full (third bit should be one),
and the program updates accordingly.

This line of code travels across the cells, looking for the cell whose second bit is one (the current cell). When that cell is
found, the program moves the pointer, changes the third bit to one, and moves the pointer over the fourth bit without changing
it (technically changing it twice, which has the same effect). At this point, the bit under the pointer belongs to the next
cell. If the bit was zero (indicating the absence of a valid cell) the program goes to State U. Otherwise, it goes to State KA.
QD >> 1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001    1    State QC >> 01    1
000000001 ~> State QD    1    01    1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000001 ~> State U    0000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 -> State KA

This line navigates to the first valid cell and redirects to State QC.
QB >> 1    001 ~> QB    00000000000001 -> QC

This line travels four bits at a time (one cell at a time) until the first bit after all the valid cells has been reached, then
it redirects to State QB.
QA >> 01    1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001    1    000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000001    State Q >> 1    0000000000001 ~> State QB    00000000001 -> State QA


This line of code is called if the previous cell's third bit was one. First, the line changes the second bit of the current cell
to one. It then branches out based on the fourth bit of the current cell. If the fourth bit was zero (immediately changes to
one), the program goes to State Q. If the fourth bit was one (changes to zero and then changes to one), the program goes to
State R.

State P >> 1    01    1    01    1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000001    1    000000000001 ~> State Q    000000000000000
000000000000000000000000000000001 -> State R


O states

Once the O states are reached, there is enough information to know the current cell should be full (third bit should be one),
and the program updates accordingly.

This line of code travels across the cells, looking for the cell whose second bit is one (the current cell). When that cell is
found, the program moves the pointer, changes the third bit to one, and moves the pointer over the fourth bit without changing
it (technically changing it twice, which has the same effect). At this point, the bit under the pointer belongs to the next
cell. If the bit was zero (indicating the absence of a valid cell) the program goes to State U. Otherwise, it goes to State KA.
State OD >> 1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001    1    State OC >> 01
1    000000001 ~> State OD    1    01    1    0000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000001    1    0000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000001 ~> State U    0000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000001 -> State KA

This line navigates to the first valid cell and redirects to State OC.
State OB >> 1    001 ~> State OB    00000000000001 -> State OC

This line travels four bits at a time (one cell at a time) until the first bit after all the valid cells has been reached, then
it redirects to State OB.
State OA >> 01    1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001    1
State O >> 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000001    1    0000000000001 ~> State OB    00000000001 -> State OA


N states

Once the N states are reached, there is enough information to know the current cell should be empty (third bit should be zero),
and the program updates accordingly.

This line changes the value of the third bit to zero and moves the pointer over the fourth bit without changing it (technically
changing it twice, which has the same effect). At this point, the bit under the pointer belongs to the next cell. If the bit was
zero (indicating the absence of a valid cell) the program goes to State U. Otherwise, it goes to State KA.
State NE >> 1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000001 ~> State U    000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000001 -> State KA

This line of code travels across the cells, looking for the cell whose second bit is one (the current cell). When that cell is
found, the program moves the pointer to the third bit and redirects to State NE.
State ND >> 1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001    1    State NC >> 01
1    000000001 ~> State ND    1    01    00000000000000001 -> State NE

This line navigates to the first valid cell and redirects to State NC.
State NB >> 1    001 ~> State NB    0000000001 -> State NC

This line travels four bits at a time (one cell at a time) until the first bit after all the valid cells has been reached, then
it redirects to State NB.
State NA >> 01    1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001    1    000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000001    State N >> 1    0000000000001 ~> State NB    00000000001 -> State NA


This line of code is called if the previous cell's third bit was zero. First, the line changes the second bit of the current
cell to one. It then branches out based on the fourth bit of the current cell. If the fourth bit was zero (immediately changes
to one), the program goes to State N. If the fourth bit was one (changes to zero and then changes to one), the program goes to
State O.

State M >> 1    01    1    01    1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000001    1    000000000001 ~> State N    000000000000000
0000000000000000000000000001 -> State O


First, this line changes the second bit of what is now the previous cell to zero. Then, it branches out based on the fourth bit
of the previous cell. If the fourth bit was zero (immediately changes to one), the program goes to State M. If the fourth bit
was one (changes to zero and then changes to one), the program goes to State P.

State L >> 1    0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000001    1    00000000000001 ~> State M    00000000000000000000000000000000000
0000000000000000000000000000000000000000000001 -> State P


This line is called right after a cell value has been updated and no valid cells exist past it. It changes the first bit after
all valid cells to one, thus creating a new valid cell, then it navigates back to State H to print out all the newly updated
cells.

State U >> 01    1    0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00001 -> State H


K states

If the program is coming from the H states, it will always start with State K and conclude with State L. The line of code below
becomes relavant right after the third bit of a cell value is updated.

This line of code travels across the cells, looking for the one whose second bit is one. When that cell is found, the program
redirects to State L.
KC >> 1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001    1
State KB >> 0000000001    1    000000001 ~> State KC    000000000000000001 -> State L

At this point, the pointer lies on the first bit past all the valid cells. This line navigates to the first valid cell and
redirects to State KB.
K >> 1    001 ~> State K    00000001 -> State KB

This line is called right after a cell value has been updated and other valid cells exist past it. Here, the program travels
four bits at a time (one cell at a time) until the first bit after all the valid cells has been reached, then it redirects to
State K.
KA >> 01    1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001    1    000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000001    1    0000000000001 ~> State K    00000000001 -> State KA


J states

These states are called when the cell value is empty. They print a space character, change the fourth bit to match the third (so
that both are equal to zero), and return to State HE.

State JA >> 2222222222222221    01    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000001 -> State HE

State J >> 2222201    2000001 -> State JA


I states

These states are called when the cell value is full. They print a full block character, change the fourth bit to match the third
(so that both are equal to one), and return to State HD. (Note that because the fourth bit's value changes to zero at State HD,
the program will always continue to State HE, which changes the fourth bit's value back to one.)

State ID >> 222222201    1    01    00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000001 -> State HD

State IC >> 2201     20000001 -> State ID

State IB >> 201      200001 -> State IC

State IA >> 22201    2200001 -> State IB

State I >>  22201    200001 -> State IA


H states

From State H to State HB, the program first prints out the newline character. At this point, the pointer will be past the start
of all valid cells. State HC and the state that follows navigate back to the first valid cell. Next, the program marks the
second bit of the first cell as one, leaving the rest as zeroes by default. This ensures the K States start with the first cell.

Then, the rest of the states move across the list of bits, redirecting to State I or State J based on the value of the third bit
of each cell. States I and J print the appropriate character, ensure the fourth bit matches up with the third, and return back
to the H states. This process repeats until the values for all cells have been printed, and pointer lies on the first bit past
all the valid cells. At this point, the program redirects to State K.

State HC >> 1    001 ~> State HC    1    01    1    000000000000000000001 ~> State J    0000000001 -> State I

State HF >> 1    01    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000001    1    000000000000000000000000001 ~> State J
State HD >> 0000000000000001 ~> State I    State HE >> 1    0000000000000000000000000000000000000000000001 ~> State K
00000000001 -> State HF

State HB >> 2222222222222222201    0000000000000000001 -> State HC

State HA >> 201    200001 -> State HB

State H  >> 201    200001 -> State HA



Section II

The line of code starting with State G is only called once. It makes the pointer travel four bits at a time (one cell at a time)
until what should be the first bit of a cell is zero (marking an invalid cell). This means all valid cells are behind the
pointer. When that happens, the program redirects to state H, transitioning into Section III.

State G >> 01    1    0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000001    1    0000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001    1    0000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000001    1    000000000001 ~> State H    00000000001 -> State G


F states

These four lines of code perform a very simple task. They add four new bits to the end of Axios' list of bits, and make the
first of these bits one, thus creating a new valid cell.

Each line starts on the first zero bit marking an invalid cell. First, the pointer moves until the bit underneath CHANGES to
zero (indicating it was one before, and thus a valid cell). Then, the line of code proceeds to move the pointer four bits at a
time (without changing anything) until it hits a bit whose value was zero.

Since moving to the end of Axios' list of bits adds a new bit every time, these four lines add all four new bits, initially set
to the pattern (one zero zero zero). At the end, the program returns to State BB to set the value of the new cell according the
next character inputted by the user.

State FF >> 1    001    State FG >> 1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 ~> State BB
00000000001 -> State FG

State FD >> 1    001    State FE >> 1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000001    1    0000000000000000000001 ~> State FF    00000000001 -> State FE

State FB >> 1    001    State FC >> 1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000001    1    000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000001    1    0000000000000000000001 ~> State FD    00000000001 -> State FC

State F >> 1    001    State FA >> 1    0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000001    1    0000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
1    000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000001    1    0000000000000000000001 ~> State FB    00000000001 -> State FA


E states

A character whose first bit is one (little-endian order) is interpretted as an full cell. Thus, the E states make the cell in
question full by make the last two bits one. By the time the program leaves the E states, the cell will contain these values:
one ? one one (the first cell's second bit is one, and the others' second bits are zeroes)

At the end, the pointer will move to the bit immediately after the fourth bit of the current cell. If that bit is zero, (i.e. no
valid cell follows) the program goes to State F to add a new cell. Otherwise, the program returns to State BB to record another
character from the user's input.

State EB >> 01    1    01    1    00000000000000001 ~> State F    00000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000001 -> State BB

State EA >> 3333333333333333333300000001 ~> State EB    000000001 -> State EB

State E >> 01    1    0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000001    1    01    000000001 -> State EA


D states

A character whose first bit is zero (little-endian order) and is not the newline character is interpreted as an empty cell.
Thus, the D states make the cell in question empty by make the last two bits zero. By the time the program leaves the D states,
the cell will contain these values: one ? zero zero (the first cell's second bit is one, and the others' second bits are zeroes)

At the end, the pointer will move to the bit immediately after the fourth bit of the current cell. If that bit is zero, (i.e. no
valid cell follows) the program goes to State F to add a new cell. Otherwise, the program returns to State BB to record another
character from the user's input.

State DB >> 1    0000000000000000000000000001 ~> State F    00000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000001 -> State BB

State DA >> 1    01    0000001 -> State DB

State D >> 01    1    0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000001    1    01    0000000001 -> State DA


C states
The C states act as a ladder to State D, emptying the unimportant bits of user input so that the program may proceed to reading
the next character inputted by the user.

State CS >> 300000001 ~> State D    000000001 -> State D
State CR >> 30001 ~> State CS       00001 -> State CS
State CQ >> 30001 ~> State CR       00001 -> State CR
State CP >> 30001 ~> State CQ       00001 -> State CQ
State CO >> 30001 ~> State CP       00001 -> State CP
State CN >> 30001 ~> State CO       00001 -> State CO
State CM >> 30001 ~> State CN       00001 -> State CN
State CL >> 30001 ~> State CM       00001 -> State CM
State CK >> 30001 ~> State CL       00001 -> State CL
State CJ >> 30001 ~> State CK       00001 -> State CK
State CI >> 30001 ~> State CJ       00001 -> State CJ
State CH >> 30001 ~> State CI       00001 -> State CI
State CG >> 30001 ~> State CH       00001 -> State CH
State CF >> 30001 ~> State CG       00001 -> State CG
State CE >> 30001 ~> State CF       00001 -> State CF
State CD >> 30001 ~> State CE       00001 -> State CE
State CC >> 30001 ~> State CD       00001 -> State CD
State CB >> 30001 ~> State CC       00001 -> State CC
State CA >> 30001 ~> State CB       00001 -> State CB


B states

These states take user input, sort them into three categories, and redirect to another group of states based on said category.
The categories are:
  *  Character whose first encoded bit is one (little-endian order)
     *  Immediately redirects to State E
  *  Newline character
     *  Ends the process of reading user input and redirects to State G, where the program will quickly shift to Section III
     *  The current cell (unless it's the first) and all following cells will be empty
  *  Character whose first encoded bit is zero (little-endian order), but is NOT the newline character
     *  Redirects to the one of the C states, depending on how long it takes for the program to determine it is not the
        newline character
     *  (It is theoretically possible for a character with a particular Unicode encoding to redirect to State D, but no such
        character exists at the time I am writing this.)
  *  If the user presses enter (submitting a newline character) without first typing any other characters, the first cell will
     be full and the rest will be empty.

State BD >> 30000000001 ~> State CD    30000000000001 ~> State CE    30000000000000001 ~> State CF
30000000000000000001 ~> State CG    30000000000000000000001 ~> State CH    30000000000000000000000001 ~> State CI
30000000000000000000000000001 ~> State CJ    30000000000000000000000000000001 ~> State CK
30000000000000000000000000000000001 ~> State CL    30000000000000000000000000000000000001 ~> State CM
30000000000000000000000000000000000000001 ~> State CN    30000000000000000000000000000000000000000001 ~> State CO
30000000000000000000000000000000000000000000001 ~> State CP    30000000000000000000000000000000000000000000000001 ~> State CQ
30000000000000000000000000000000000000000000000000001 ~> State CR
30000000000000000000000000000000000000000000000000000001 ~> State CS
30000000000000000000000000000000000000000000000000000000000001 ~> State D (no currently existing character redirects to State D)
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000001 -> State G

State BC >> 3000000000000000000000001 ~> State CB    3000000000000000000001 ~> State BD
0000000000000000000000000001 -> State CC

State BA >> 1    State BB >> 300000000000000000000000000000000000000000000000000000000000000000000000000000001 ~> State E
30000001 ~> State BC 0000000000000000000000000001 -> State CA

The line of code below, along with State BA, is only called once. This line moves the pointer twice, changing the bit it passes
through. Then it redirects to State BA. After the program moves from State BA to State BB, two cells will exist, as represented
by the following bits: (one one one one) (one zero zero zero) zero
State B >> 1    1    0000000 -> State BA
